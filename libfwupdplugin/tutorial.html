<!--
SPDX-FileCopyrightText: fwupd Development Team

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>FwupdPlugin &ndash; 1.0: Plugin Tutorial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  
  <meta property="og:image:width" content="256"/>
  <meta property="og:image:height" content="256"/>
  <meta property="og:image:secure_url" content="org.freedesktop.fwupd.svg"/>
  <meta property="og:image:alt" content="FwupdPlugin-1.0"/>
  

  
  <meta property="og:title" content="FwupdPlugin: Plugin Tutorial"/>
  <meta property="og:description" content="Reference for FwupdPlugin-1.0: Plugin Tutorial"/>
  <meta name="twitter:title" content="FwupdPlugin: Plugin Tutorial"/>
  <meta name="twitter:description" content="Reference for FwupdPlugin-1.0: Plugin Tutorial"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap_fwupdplugin.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      <div class="section">
        <a href="index.html"><img src="org.freedesktop.fwupd.svg" class="logo"/></a>
      </div>
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">FwupdPlugin</a></h3>
        <p>API Version: 1.0</p>
        
        <p>Library Version: 2.0.9</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2025.3</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    Plugin Tutorial
    <a href="#title" class="anchor"></a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <h2 id="introduction">Introduction<a class="md-anchor" href="#introduction" title="Permanent link"></a></h2>
<p>At the heart of fwupd are plugins that gets run at startup, when devices
get hotplugged and when updates are done.
The idea is we have lots of small plugins that each do one thing, and are
ordered by dependencies against each other at runtime.
Using plugins we can add support for new hardware or new policies without making
big changes all over the source&nbsp;tree.</p>
<p>There are broadly 3 types of plugin&nbsp;methods:</p>
<ul>
<li><strong>Mechanism</strong>: Upload binary data into a specific hardware&nbsp;device.</li>
<li><strong>Policy</strong>: Control the system when updates are happening, e.g. preventing the
              user from&nbsp;powering-off.</li>
<li><strong>Helpers</strong>: Providing more metadata about devices, for instance handling device&nbsp;quirks.</li>
</ul>
<p>A plugin only needs to define the vfuncs that are required, and the plugin name
is taken automatically from the&nbsp;GType.</p>
<div class="codehilite"><pre><span></span><code>/* fu-foo-plugin.h
 *
 * Copyright 2022 Richard Hughes &lt;richard@hughsie.com&gt;
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 */

#pragma once

#include &lt;fwupdplugin.h&gt;

G_DECLARE_FINAL_TYPE(FuFooPlugin, fu_foo_plugin, FU, FOO_PLUGIN, FuPlugin)

/* fu-foo-plugin.c
 *
 * Copyright Richard Hughes &lt;richard@hughsie.com&gt;
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 */

#include &quot;config.h&quot;

#include &quot;fu-foo-plugin.h&quot;

struct _FuFooPlugin {
    FuPlugin parent_instance;
    gpointer proxy;
};

G_DEFINE_TYPE(FuFooPlugin, fu_foo_plugin, FU_TYPE_PLUGIN)

static gboolean
fu_foo_plugin_startup(FuPlugin *plugin, FuProgress *progress, GError **error)
{
    FuPluginData *data = fu_plugin_get_data(plugin);
    self-&gt;proxy = create_proxy();
    if(self-&gt;proxy == NULL) {
        g_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_SUPPORTED,
                    &quot;failed to create proxy&quot;);
        return FALSE;
    }
    return TRUE;
}

static void
fu_foo_plugin_init(FuFooPlugin *self)
{
}

static void
fu_foo_constructed(GObject *obj)
{
    FuPlugin *plugin = FU_PLUGIN(obj);
    FuContext *ctx = fu_plugin_get_context(plugin);
    fu_plugin_add_rule(plugin, FU_PLUGIN_RULE_RUN_BEFORE, &quot;dfu&quot;);
}

static void
fu_foo_finalize(GObject *obj)
{
    FuFooPlugin *self = FU_FOO_PLUGIN(obj);
    destroy_proxy(self-&gt;proxy);
    G_OBJECT_CLASS(fu_foo_plugin_parent_class)-&gt;finalize(obj);
}

static void
fu_foo_plugin_class_init(FuFooPluginClass *klass)
{
    FuPluginClass *plugin_class = FU_PLUGIN_CLASS(klass);
    GObjectClass *object_class = G_OBJECT_CLASS(klass);

    object_class-&gt;constructed = fu_foo_constructed;
    object_class-&gt;finalize = fu_foo_finalize;
    plugin_class-&gt;startup = fu_foo_plugin_startup;
}
</code></pre></div>

<p>We have to define when our plugin is run in reference to other plugins, in this
case, making sure we run before the <code>dfu</code> plugin.</p>
<p>For most plugins it does not matter in what order they are run and this
information is not&nbsp;required.</p>
<h2 id="creating-an-abstract-device">Creating an abstract device<a class="md-anchor" href="#creating-an-abstract-device" title="Permanent link"></a></h2>
<p>This section shows how you would create a device which is exported to the daemon
and thus can be queried and updated by the client software.
The example here is all hardcoded, and a true plugin would have to
derive the details about the <code>FuDevice</code> from the hardware, for example reading
data from <code>sysfs</code> or <code>/dev</code>.</p>
<div class="codehilite"><pre><span></span><code>static gboolean
fu_foo_plugin_coldplug(FuPlugin *plugin, FuProgress *progress, GError **error)
{
    g_autoptr(FuDevice) dev = NULL;
    fu_device_set_id(dev, &quot;dummy-1:2:3&quot;);
    fu_device_add_instance_id(dev, &quot;2d47f29b-83a2-4f31-a2e8-63474f4d4c2e&quot;);
    fu_device_set_version(dev, &quot;1.2.3&quot;);
    fu_device_get_version_lowest(dev, &quot;1.2.2&quot;);
    fu_device_get_version_bootloader(dev, &quot;0.1.2&quot;);
    fu_device_add_icon(dev, &quot;computer&quot;);
    fu_device_add_flag(dev, FWUPD_DEVICE_FLAG_UPDATABLE);
    fu_plugin_device_add(plugin, dev);
    return TRUE;
}

static void
fu_foo_plugin_class_init(FuFooPluginClass *klass)
{
    …
    plugin_class-&gt;coldplug = fu_foo_plugin_coldplug;
    …
}
</code></pre></div>

<p>This shows a lot of the plugin architecture in action.
Some notable&nbsp;points:</p>
<ul>
<li>
<p>The device <span class="caps">ID</span> (<code>dummy-1:2:3</code>) has to be unique on the system between all
plugins, so including the plugin name as a prefix is probably a good&nbsp;idea.</p>
</li>
<li>
<p>The <span class="caps">GUID</span> value can be generated automatically using
<code>fu_device_add_instance_id(dev,"some-identifier")</code> but is quoted here explicitly. The
<span class="caps">GUID</span> value has to match the <code>provides</code> value in the <code>.metainfo.xml</code> file for the
firmware update to&nbsp;succeed.</p>
</li>
<li>
<p>Setting a display name and an icon is a good idea in case the <span class="caps">GUI</span> software
needs to display the device to the user. Icons can be specified using a full
path, although icon theme names should be preferred for most&nbsp;devices.</p>
</li>
<li>
<p>The <code>FWUPD_DEVICE_FLAG_UPDATABLE</code> flag tells the client code that the device
is in a state where it can be updated. If the device needs to be in a special
mode (e.g. a bootloader) then the <code>FWUPD_DEVICE_FLAG_NEEDS_BOOTLOADER</code> flag can
also be used. If the update should only be allowed when there is <span class="caps">AC</span> power
available to the computer (i.e. not on battery) then
<code>FWUPD_DEVICE_FLAG_REQUIRE_AC</code> should be used as well. There are other flags and
the <span class="caps">API</span> documentation should be used when choosing what flags to use for each
kind of&nbsp;device.</p>
</li>
<li>
<p>Setting the lowest allows client software to refuse downgrading the device to
specific versions.
This is required in case the upgrade migrates some kind of data-store so as to
be incompatible with previous versions.
Similarly, setting the version of the bootloader (if known) allows the firmware
to depend on a specific bootloader version, for instance allowing signed
firmware to only be installable on hardware with a bootloader new enough to
deploy&nbsp;it.</p>
</li>
</ul>
<h3 id="setting-the-device-version">Setting the device version<a class="md-anchor" href="#setting-the-device-version" title="Permanent link"></a></h3>
<p>Although the version can be set easily as a string using <code>fu_device_set_version()</code>
directly, it is more flexible to tell fwupd what the <em>version format</em> should be,
and to allow the daemon to convert it to a string&nbsp;internally.</p>
<p>This also means that if we get the version format from a quirk file, or from metadata,
or even if it changes at runtime &#8212; the correct string version is used at all&nbsp;times.</p>
<div class="codehilite"><pre><span></span><code>static gchar *
fu_foo_device_convert_version(FuDevice *device, guint64 version_raw)
{
    return fu_version_from_uint24(version_raw, FWUPD_VERSION_FORMAT_TRIPLET);
}

static void
fu_foo_device_class_init(FuFooDeviceClass *klass)
{
    …
    device_class-&gt;convert_version = fu_foo_device_convert_version;
    …
}
</code></pre></div>

<h2 id="mechanism-plugins">Mechanism Plugins<a class="md-anchor" href="#mechanism-plugins" title="Permanent link"></a></h2>
<p>Although it would be a wonderful world if we could update all hardware using a
standard shared protocol this is not the universe we live in.
Using a mechanism like <span class="caps">DFU</span> or UpdateCapsule means that fwupd will just work
without requiring any special code, but for the real world we need
to support vendor-specific update protocols with layers of backwards&nbsp;compatibility.</p>
<p>When a plugin has created a device that is <code>FWUPD_DEVICE_FLAG_UPDATABLE</code> we can
ask the daemon to update the device with a suitable <code>.cab</code> file.
When this is done the daemon checks the update for compatibility with the device,
and then calls the vfuncs to update the&nbsp;device.</p>
<div class="codehilite"><pre><span></span><code>static gboolean
fu_foo_plugin_write_firmware(FuPlugin *plugin,
                             FuDevice *dev,
                             GBytes *blob_fw,
                             FuProgress *progress,
                             FwupdInstallFlags flags,
                             GError **error)
{
    gsize sz = 0;
    guint8 *buf = g_bytes_get_data(blob_fw, &amp;sz);
    /* write &#39;buf&#39; of size &#39;sz&#39; to the hardware */
    return TRUE;
}

static void
fu_foo_plugin_class_init(FuFooPluginClass *klass)
{
    …
    plugin_class-&gt;write_firmware = fu_foo_plugin_write_firmware;
    …
}
</code></pre></div>

<p>It&#8217;s important to note that the <code>blob_fw</code> is the binary firmware file
(e.g. <code>.dfu</code>) and <strong>not</strong> the <code>.cab</code> binary&nbsp;data.</p>
<p>If <code>FWUPD_INSTALL_FLAG_FORCE</code> is used then the usual checks done by the flashing
process can be relaxed (e.g. checking for quirks), but please don&#8217;t brick the
users hardware even if they ask you&nbsp;to.</p>
<h2 id="policy-helpers">Policy Helpers<a class="md-anchor" href="#policy-helpers" title="Permanent link"></a></h2>
<p>For some hardware, we might want to do an action before or after the actual
firmware is squirted into the device.
This could be something as simple as checking the system battery level is over a
certain threshold, or it could be as complicated as ensuring a vendor-specific
<span class="caps">GPIO</span> is asserted when specific types of hardware are&nbsp;updated.</p>
<div class="codehilite"><pre><span></span><code>static gboolean
fu_foo_plugin_prepare(FuPlugin *plugin, FuDevice *device, GError **error)
{
    if (fu_device_has_flag(device, FWUPD_DEVICE_FLAG_REQUIRE_AC &amp;&amp; !on_ac_power()) {
            g_set_error_literal(error,
                                FWUPD_ERROR,
                                FWUPD_ERROR_AC_POWER_REQUIRED,
                                &quot;Cannot install update &quot;
                                &quot;when not on AC power&quot;);
            return FALSE;
    }
    return TRUE;
}

static gboolean
fu_foo_plugin_cleanup(FuPlugin *plugin, FuDevice *device, GError **error)
{
    return g_file_set_contents(&quot;/var/lib/fwupd/something&quot;,
                               fu_device_get_id(device), -1, error);
}

static void
fu_foo_plugin_class_init(FuFooPluginClass *klass)
{
    …
    plugin_class-&gt;prepare = fu_foo_plugin_prepare;
    plugin_class-&gt;cleanup = fu_foo_plugin_cleanup;
    …
}
</code></pre></div>

<h2 id="detaching-to-bootloader-mode">Detaching to bootloader mode<a class="md-anchor" href="#detaching-to-bootloader-mode" title="Permanent link"></a></h2>
<p>Some hardware can only be updated in a special bootloader mode, which for most
devices can be switched to automatically.
In some cases the user to do something manually, for instance re-inserting the
hardware with a secret button&nbsp;pressed.</p>
<p>Before the device update is performed the fwupd daemon runs an optional
<code>update_detach()</code> vfunc which switches the device to bootloader&nbsp;mode.</p>
<p>After the update (or if the update fails) an the daemon runs an optional
<code>update_attach()</code> vfunc which should switch the hardware back to runtime mode.
Finally an optional <code>update_reload()</code> vfunc is run to get the new firmware
version from the&nbsp;hardware.</p>
<p>The optional vfuncs are <strong>only</strong> run on the plugin currently registered to
handle the device <span class="caps">ID</span>, although the registered plugin can change during the
attach and detach&nbsp;phases.</p>
<div class="codehilite"><pre><span></span><code>static gboolean
fu_foo_plugin_detach(FuPlugin *plugin, FuDevice *device, FuProgress *progress, GError **error)
{
    if (hardware_in_bootloader)
        return TRUE;
    return _device_detach(device, progress, error);
}

static gboolean
fu_foo_plugin_attach(FuPlugin *plugin, FuDevice *device, FuProgress *progress, GError **error)
{
    if (!hardware_in_bootloader)
        return TRUE;
    return _device_attach(device, progress, error);
}

static gboolean
fu_foo_plugin_reload(FuPlugin *plugin, FuDevice *device, GError **error)
{
    g_autofree gchar *version = _get_version(plugin, device, error);
    if (version == NULL)
        return FALSE;
    fu_device_set_version(device, version);
    return TRUE;
}

static void
fu_foo_plugin_class_init(FuFooPluginClass *klass)
{
    …
    plugin_class-&gt;detach = fu_foo_plugin_detach;
    plugin_class-&gt;attach = fu_foo_plugin_attach;
    plugin_class-&gt;reload = fu_foo_plugin_reload;
    …
}
</code></pre></div>

<h2 id="the-plugin-object-cache">The Plugin Object Cache<a class="md-anchor" href="#the-plugin-object-cache" title="Permanent link"></a></h2>
<p>The fwupd daemon provides a per-plugin cache which allows objects to be added,
removed and queried using a specified key.
Objects added to the cache must be <code>GObject</code>s to enable the cache objects to be
properly&nbsp;refcounted.</p>
<h2 id="debugging-a-plugin">Debugging a Plugin<a class="md-anchor" href="#debugging-a-plugin" title="Permanent link"></a></h2>
<p>If the fwupd daemon is started with <code>--plugin-verbose=$plugin</code> then the
environment variable <code>FWUPD_$PLUGIN_VERBOSE</code> is set process-wide.
This allows plugins to detect when they should output detailed debugging
information that would normally be too verbose to keep in the journal.
For example, using <code>--plugin-verbose=logitech_hidpp</code> would set
<code>FWUPD_LOGITECH_HID_VERBOSE=1</code>.</p>
<h2 id="using-existing-code-to-develop-a-plugin">Using existing code to develop a plugin<a class="md-anchor" href="#using-existing-code-to-develop-a-plugin" title="Permanent link"></a></h2>
<p>It is not usually possible to share a plugin codebase with firmware update
programs designed for other operating&nbsp;systems.</p>
<p>Matching the same rationale as the Linux kernel, trying to use one code base
between projects with a compatibility shim layer in-between is real headache to&nbsp;maintain.</p>
<p>The general consensus is that trying to use a abstraction layer for hardware is
a very bad idea as you&#8217;re not able to take advantage of the platform specific
helpers &#8212; for instance quirk files and the custom GType device&nbsp;creation.</p>
<p>The time the vendor saves by creating a shim layer and importing existing source
code into fwupd will be overtaken 100x by upstream maintenance costs longer term,
which isn&#8217;t&nbsp;fair.</p>
<p>In a similar way, using C++ rather than GObject C means expanding the test matrix
to include clang in C++ mode and <span class="caps">GNU</span> g++ too.
It&#8217;s also doubled the runtime requirements to now include both the C standard library
as well as the C++ standard library and increases the dependency&nbsp;surface.</p>
<p>Most rewritten fwupd plugins at up to x10 smaller than the standalone code as they
can take advantage of helpers provided by fwupd rather than re-implementing error
handling, device quirking and data&nbsp;chunking.</p>
<h2 id="general-guidelines-for-plugin-developers">General guidelines for plugin developers<a class="md-anchor" href="#general-guidelines-for-plugin-developers" title="Permanent link"></a></h2>
<h3 id="general-considerations">General considerations<a class="md-anchor" href="#general-considerations" title="Permanent link"></a></h3>
<p>When adding support for a new device in fwupd some things need to be
evaluated&nbsp;beforehand:</p>
<ul>
<li>how the hardware is discovered, identified and&nbsp;polled.</li>
<li>how to communicate with the device (<span class="caps">USB</span>? file&nbsp;open/read/write?)</li>
<li>does the device need to be switched to bootloader mode to make it&nbsp;upgradable?</li>
<li>about the format of the firmware files, do they follow any standard?
  are they already supported in&nbsp;fwupd?</li>
<li>about the update protocol, is it already supported in&nbsp;fwupd?</li>
<li>Is the device composed of multiple different devices? Are those
  devices enumerated and programmed independently or are they accessed
  and flashed through a &#8220;root&#8221;&nbsp;device?</li>
</ul>
<p>In most cases, even if the features you need aren&#8217;t implemented yet,
there&#8217;s already a plugin that does something similar and can be used as
an example, so it&#8217;s always a good idea to read the code of the existing
plugins to understand how they work and how to write a new one, as no
documentation will be as complete and updated as the code
itself. Besides, the mechanisms implemented in the plugin collection are
very diverse and the best way of knowing what can be done is to check
what is already been&nbsp;done.</p>
<h3 id="leveraging-existing-fwupd-code">Leveraging existing fwupd code<a class="md-anchor" href="#leveraging-existing-fwupd-code" title="Permanent link"></a></h3>
<p>Depending on how much of the key items for the device update (firmware
format, update protocol, transport layer) are already supported in
fwupd, the work needed to add support for a new device can range from
editing a quirk file to having to fully implement new device and
firmware types, although in most cases fwupd already implements helper
code that can be&nbsp;extended.</p>
<h4 id="if-the-firmware-format-update-protocol-and-device-communication-are-already-supported">If the firmware format, update protocol and device communication are already supported<a class="md-anchor" href="#if-the-firmware-format-update-protocol-and-device-communication-are-already-supported" title="Permanent link"></a></h4>
<p>This is the simplest case, where an existing plugin fully implements the
update process for the new device and we only have to let fwupd know
that that plugin should be used for our device. In this case the only
thing to do is to edit the plugin quirk file and add the device
identifier in the format expected by the plugin together with any
required options for it (at least a &#8220;Plugin&#8221; key to declare that this is
the plugin to use for this device). Example:
<a href="https://github.com/fwupd/fwupd/blob/main/plugins/vli/vli-usbhub.quirk">https://github.com/fwupd/fwupd/blob/main/plugins/vli/vli-usbhub.quirk</a></p>
<h4 id="if-the-device-type-is-not-supported">If the device type is not supported<a class="md-anchor" href="#if-the-device-type-is-not-supported" title="Permanent link"></a></h4>
<p>Then we have to take a look at the existing device types and check if
there&#8217;s any of them that have similarities and which can be partially
reused or extended for our device. If the device type is derivable and
it can support our new device by implementing the proper vfuncs, then we
can simply subclass it and add the required functionalities. If not,
we&#8217;ll need to study what is the best way to reuse it for our&nbsp;needs.</p>
<p>If a plugin already implements most of the things we need besides the
device type, we can add our new device type to that plugin. Otherwise we
should create a plugin that will hold the new device&nbsp;type.</p>
<p>The core fwupd code contains some basic device types (such as
<a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-udev-device.c">FuUdevDevice</a>, <a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-usb-device.c">FuUsbDevice</a>, <a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-bluez-device.c">FuBluezDevice</a>) that can be used as a base
type for most devices in case we have to implement our own device
access, identification and communication from&nbsp;scratch.</p>
<p>If the device is natively visible by the <span class="caps">OS</span>, most of the time fwupd can
detect the device connection and disconnection by listening to udev
events, but a supported device may also be not directly accessible from
the <span class="caps">OS</span> &#8212; for example, a composite device that contains an updatable chip
that&#8217;s connected through <span class="caps">I2C</span> to a <span class="caps">USB</span> hub that acts as an interface. In
that case, the device discovery and enumeration must be programmed by
the developer, but the same device identification and management
mechanisms apply in all cases. See the &#8220;Creating a new device type&#8221; and
&#8220;Device identification&#8221; below for more&nbsp;details.</p>
<h4 id="if-the-firmware-type-is-not-supported">If the firmware type is not supported<a class="md-anchor" href="#if-the-firmware-type-is-not-supported" title="Permanent link"></a></h4>
<p>Same as with the new device type, there could be an existing firmware
type that can be used as a base type for our new type, so first of all
we should look for firmware types that are similar to the one we&#8217;re
using. Then, choosing where to define the new type depends on whether
there&#8217;s already a plugin that implements most of the functionalities we
need or&nbsp;not.</p>
<h3 id="example-extending-a-firmware-type">Example: extending a firmware type<a class="md-anchor" href="#example-extending-a-firmware-type" title="Permanent link"></a></h3>
<p>Our firmware files are Intel <span class="caps">HEX</span> files that have optional
vendor-specific sections at fixed addresses, this is not supported by
any firmware type in fwupd out of the box but the <a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-ihex-firmware.c">FuIhexFirmare</a> class
parses and models a standard Intel <span class="caps">HEX</span> file, so we can create a subclass
of it for our firmware type and override the parse method so that it
calls the method from the parent class, which would parse the file, and
then we can get the data with <code>fu_firmware_get_bytes()</code> and do the rest of
the custom parsing. Example:
<a href="https://github.com/fwupd/fwupd/blob/main/plugins/analogix/fu-analogix-firmware.c">https://github.com/fwupd/fwupd/blob/main/plugins/analogix/fu-analogix-firmware.c</a></p>
<h3 id="example-extending-a-device-type">Example: extending a device type<a class="md-anchor" href="#example-extending-a-device-type" title="Permanent link"></a></h3>
<p>Communication with our new device is carried out by doing
read/write/ioctl operations on a device file, but using a custom
protocol that is not supported in&nbsp;fwupd.</p>
<p>For this type of device we can create a new type derived from
<code>FuUdevDevice</code>, which takes care of discovering this type of devices,
possibly using a vendor-specific protocol, as well as of opening,
reading and writing device files, so we would only have to implement the
protocol on top of those primitives. (Example:
<code>fu_logitech_hidpp_runtime_bolt_poll_peripherals()</code> in
<a href="https://github.com/fwupd/fwupd/blob/main/plugins/logitech-hidpp/fu-logitech-hidpp-runtime-bolt.c">https://github.com/fwupd/fwupd/blob/main/plugins/logitech-hidpp/fu-logitech-hidpp-runtime-bolt.c</a>)
The process would be similar if our device was handled by a different
backend (<span class="caps">USB</span> or&nbsp;BlueZ).</p>
<h3 id="creating-a-new-plugin">Creating a new plugin<a class="md-anchor" href="#creating-a-new-plugin" title="Permanent link"></a></h3>
<p>The bare minimum a plugin should have is a <code>constructed</code> function that
defines the plugin characteristics such as the device type and firmware
type handled by it, the build hash and any plugin-specific quirk keys
that can be used for the&nbsp;plugin.</p>
<div class="codehilite"><pre><span></span><code>static void
fu_foo_plugin_constructed(GObject *obj)
{
    FuPlugin *plugin = FU_PLUGIN(obj);
    FuContext *ctx = fu_plugin_get_context(plugin);
    fu_plugin_add_device_gtype(plugin, FU_TYPE_STEELSERIES_MOUSE);
    fu_plugin_add_device_gtype(plugin, FU_TYPE_STEELSERIES_GAMEPAD);
}

static void
fu_foo_plugin_class_init(FuFooPluginClass *klass)
{
    plugin_class-&gt;init = fu_foo_plugin_constructed;
}
</code></pre></div>

<h3 id="creating-a-new-device-type">Creating a new device type<a class="md-anchor" href="#creating-a-new-device-type" title="Permanent link"></a></h3>
<p>Besides defining its attributes as a data type, a device type should
implement at least the usual <code>init</code>, <code>finalize</code> and <code>class_init</code> functions,
and then, depending on its parent type, which methods it overrides and
what it does, it must implement a set of device methods. These are some
of them, the complete list is in <a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-device.h">libfwupdplugin/fu-device.h</a>.</p>
<h4 id="to_string">to_string<a class="md-anchor" href="#to_string" title="Permanent link"></a></h4>
<p>Called whenever fwupd needs a human-readable representation of the&nbsp;device.</p>
<h4 id="probe">probe<a class="md-anchor" href="#probe" title="Permanent link"></a></h4>
<p>The <code>probe</code> method is called the first time a device is opened, before
actually opening it. The generic probe methods implemented in the base
device types (such as <span class="caps">USB</span>/udev) take care of basic device identification
and setting the non-specific parameters that don&#8217;t need the device to be
opened or the interface claimed (vendor id, product id, guids,&nbsp;etc.).</p>
<p>The device-specific probe method should start by calling the generic
method upwards in the class tree and then do any other specific setup
such as setting the appropriate device&nbsp;flags.</p>
<h4 id="open">open<a class="md-anchor" href="#open" title="Permanent link"></a></h4>
<p>Depending on the type of device, opening it means different things. For
instance, opening a udev device means opening its device&nbsp;file.</p>
<p>If there&#8217;s no interface-specific <code>open</code> method, then opening a device
simply calls the <code>probe()</code> and <code>setup()</code> methods (the <code>open()</code> method would be
called in between if it&nbsp;exists).</p>
<h4 id="setup">setup<a class="md-anchor" href="#setup" title="Permanent link"></a></h4>
<p>Sets parameters on the device object that require the device to be open
and have the interface claimed. <span class="caps">USB</span>/udev generic devices don&#8217;t implement
this method, this is normally implemented for each different plugin
device type if&nbsp;needed.</p>
<h4 id="prepare">prepare<a class="md-anchor" href="#prepare" title="Permanent link"></a></h4>
<p>If implemented, can be used to put the device into a mode that makes
updating possible or anything else that has to be done to a device
before updating it is&nbsp;possible.</p>
<h4 id="prepare_firmware">prepare_firmware<a class="md-anchor" href="#prepare_firmware" title="Permanent link"></a></h4>
<p>If implemented, this takes care of decompressing or parsing the firmware
data. For example, to check if the firmware is valid, if it&#8217;s suitable
for the device,&nbsp;etc.</p>
<p>It takes a stream of bytes (<code>GBytes</code>) as a parameter, representing the
raw binary firmware&nbsp;data.</p>
<p>It should create the firmware object and call the appropriate method to
load the firmware. Otherwise, if it&#8217;s not implemented for the specific
device type, the generic implementation in
<a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-device.c">libfwupdplugin/fu-device.c</a>:<code>fu_device_prepare_firmware()</code>
creates a firmware object loaded with a provided&nbsp;image.</p>
<h4 id="detach">detach<a class="md-anchor" href="#detach" title="Permanent link"></a></h4>
<p>Implemented if the device needs to be put in bootloader mode before
updating, this does all the necessary operations to put the device in
that mode. fwupd can handle the case where a device needs to be
disconnected to do the mode switch if the device has the
<code>FWUPD_DEVICE_FLAG_WAIT_FOR_REPLUG</code> flag.</p>
<h4 id="attach">attach<a class="md-anchor" href="#attach" title="Permanent link"></a></h4>
<p>The inverse of <code>detach()</code>, to configure the device back to application&nbsp;mode.</p>
<h4 id="reload">reload<a class="md-anchor" href="#reload" title="Permanent link"></a></h4>
<p>If implemented, this is called after the device update if it needs to
perform any kind of post-update&nbsp;operation.</p>
<h4 id="write_firmware">write_firmware<a class="md-anchor" href="#write_firmware" title="Permanent link"></a></h4>
<p>Writes a firmware passed as a raw byte stream. The firmware parsing and
processing is done by the firmware object, so that when this method gets
the blob it simply has to write it to the device in the appropriate way
following the device update&nbsp;protocol.</p>
<h4 id="read_firmware">read_firmware<a class="md-anchor" href="#read_firmware" title="Permanent link"></a></h4>
<p>Reads the firmware data from the device without any device-specific
configuration or serial numbers. This is meant to retrieve the current
firmware contents for verification purposes. The data read can then be
output to a binary blob using <code>fu_firmware_write()</code>.</p>
<h4 id="set_progress">set_progress<a class="md-anchor" href="#set_progress" title="Permanent link"></a></h4>
<p>Informs the daemon of the expected duration percentages for the different
phases of update. The daemon runs the <code>-&gt;detach()</code>, <code>-&gt;write_firmware()</code>,
<code>-&gt;attach()</code> and <code>-&gt;reload()</code> phases as part of the engine during the firmware
update (rather than being done by plugin-specific code) and so this vfunc
informs the daemon how to scale the progress output&nbsp;accordingly.</p>
<p>For instance, if your update takes 2 seconds to detach into bootloader mode,
10 seconds to write the firmware, 7 seconds to attach back into runtime mode
(which includes the time required for <span class="caps">USB</span> enumeration) and then 1 second to
read the new firmware version you would&nbsp;use:</p>
<div class="codehilite"><pre><span></span><code>fu_progress_set_id(progress, G_STRLOC);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_RESTART, 10, &quot;detach&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_WRITE, 45, &quot;write&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_RESTART, 40, &quot;attach&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_BUSY, 5, &quot;reload&quot;);
</code></pre></div>

<p>If however your device does not require <code>-&gt;detach()</code> or <code>-&gt;attach()</code>, and
<code>-&gt;reload()</code> is instantaneous, you still however need to include 4&nbsp;steps:</p>
<div class="codehilite"><pre><span></span><code>fu_progress_set_id(progress, G_STRLOC);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_RESTART, 0, &quot;detach&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_WRITE, 100, &quot;write&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_RESTART, 0, &quot;attach&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_BUSY, 0, &quot;reload&quot;);
</code></pre></div>

<p>If the device has multiple phases that occur when actually in the write phase
then it is perfectly okay to split up the <code>FuProgress</code> steps in the
<code>-&gt;write_firmware()</code> vfunc further. For&nbsp;instance:</p>
<div class="codehilite"><pre><span></span><code>fu_progress_set_id(progress, G_STRLOC);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_RESTART, 5, &quot;wait-for-idle&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_WRITE, 90, &quot;write&quot;);
fu_progress_add_step(progress, FWUPD_STATUS_DEVICE_RESTART, 5, &quot;reset&quot;);
</code></pre></div>

<p>It should be noted that actions that are required to be done <em>before</em> the update
should be added as a <code>-&gt;prepare()</code> vfunc, and those to be done after in the <code>-&gt;cleanup()</code>
as the daemon will then recover the hardware if the update fails. For instance,
putting the device back into a <em>normal runtime power saving</em> state should always
be done during&nbsp;cleanup.</p>
<h3 id="creating-a-new-firmware-type">Creating a new firmware type<a class="md-anchor" href="#creating-a-new-firmware-type" title="Permanent link"></a></h3>
<p>The same way a device type implements some methods to complete its
functionality and override certain behaviors, there&#8217;s a set of firmware
methods that a firmware class can (or must)&nbsp;implement:</p>
<h4 id="parse">parse<a class="md-anchor" href="#parse" title="Permanent link"></a></h4>
<p>If implemented, it parses the firmware file passed as a byte
sequence. If the firmware to be used contains a custom header, a
specific structured format or multiple images embedded, this method
should take care of processing the format and appropriately populating
the <code>FuFirmware</code> object passed as a parameter. If not implemented, the
whole data blob is taken as&nbsp;is.</p>
<h4 id="write">write<a class="md-anchor" href="#write" title="Permanent link"></a></h4>
<p>Returns a <code>FuFirmware</code> object as a byte sequence. This can be used to
output a firmware read with <code>fu_device_read_firmware()</code> as a binary&nbsp;blob.</p>
<h4 id="export">export<a class="md-anchor" href="#export" title="Permanent link"></a></h4>
<p>Converts a <code>FuFirmware</code> object to an xml representation. If not
implemented, the default implementation generates an xml representation
containing only generic attributes and, optionally, the firmware data as
well as the representation of children firmware&nbsp;nodes.</p>
<p>When testing the implementation of a new firmware type, this is useful
to show if the parsing and processing of the firmware are correct and
can be checked&nbsp;with:</p>
<div class="codehilite"><pre><span></span><code>fwupdtool firmware-parse --plugins &lt;plugin&gt; &lt;firmware_file&gt; &lt;firmware_type&gt;
</code></pre></div>

<h4 id="tokenize">tokenize<a class="md-anchor" href="#tokenize" title="Permanent link"></a></h4>
<p>If implemented it tokenizes a firmware, breaking it into&nbsp;records.</p>
<h4 id="build">build<a class="md-anchor" href="#build" title="Permanent link"></a></h4>
<p>This is the reverse of <code>export()</code>, it builds a <code>FuFirmware</code> object from
an xml&nbsp;representation.</p>
<h4 id="get_checksum">get_checksum<a class="md-anchor" href="#get_checksum" title="Permanent link"></a></h4>
<p>The default implementation returns a checksum of the payload data of a
<code>FuFirmware</code> object. Subclass it only if the checksum of your firmware
needs to be computed&nbsp;differently.</p>
<h3 id="generating-a-skeleton">Generating a skeleton<a class="md-anchor" href="#generating-a-skeleton" title="Permanent link"></a></h3>
<p>Rather than copy-and-pasting from other plugins, or using the <code>FuDeviceClass</code>
as a guide we have also provided a script that can generate a plugin&nbsp;skeleton.</p>
<p>This skeleton contains all the parts typically needed by a plugin, and plugin
developers might find it easier to delete unneeded code rather then trying to
copy and paste the correct code from other&nbsp;plugins.</p>
<p>To use this, navivate to the root directory and&nbsp;run:</p>
<div class="codehilite"><pre><span></span><code>./contrib/create-plugin.py \
    --vendor VendorName \
    --example ProductName \
    --parent Usb \
    --author &quot;Your Name&quot; \
    --email &quot;your@email.com&quot;
</code></pre></div>

<h3 id="device-identification">Device identification<a class="md-anchor" href="#device-identification" title="Permanent link"></a></h3>
<p>A device is identified in fwupd by its physical and logical ids. A
physical id represents the electrical connection of the device to the
system and many devices can have the same physical id. For example,
<code>PCI_SLOT_NAME=0000:3e:00:0</code> (see
<a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-udev-device.c">libfwupdplugin/fu-udev-device.c</a>:<code>fu_udev_device_set_physical_id()</code> for
examples) . The logical id is used to disambiguate devices with the same
physical id. Together they identify a device uniquely. There are many
examples of this in the existing plugins, such as
<code>fu_pxi_receiver_device_add_peripherals()</code> in
<a href="https://github.com/fwupd/fwupd/blob/main/plugins/pixart-rf/fu-pxi-receiver-device.c">https://github.com/fwupd/fwupd/blob/main/plugins/pixart-rf/fu-pxi-receiver-device.c</a></p>
<p>Besides that, each device type will have a unique instance id, which is
a string representing the device subsystem, vendor, model and revision
(specific details depend on the device type). This should identify a
device type in the system, that is, a particular device type, model and
revision by a specific vendor will have a defined instance id and two of
the same device will have the same instance id (see
<a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-udev-device.c">libfwupdplugin/fu-udev-device.c</a>:<code>fu_udev_device_probe()</code>
for&nbsp;examples).</p>
<p>One or more GUIDs are generated for a device from its identifying
attributes, these GUIDs are then used to match a firmware metadata
against a specific device type. See the implementation of the many
<code>probe()</code> methods for&nbsp;examples.</p>
<h3 id="support-for-ble-devices">Support for BLE devices<a class="md-anchor" href="#support-for-ble-devices" title="Permanent link"></a></h3>
<p><span class="caps">BLE</span> support in fwupd on Linux is provided by BlueZ. If the device
implements the standard <span class="caps">HID</span>-over-<span class="caps">GATT</span> <span class="caps">BLE</span> profile, then communication
with the device can be done through the <a href="https://www.kernel.org/doc/html/latest/hid/hidraw.html">hidraw
interface</a>. If
the device implements a custom <span class="caps">BLE</span> profile instead, then it will have to
be managed by the <code>FuBluezBackend</code>, which uses the BlueZ DBus interface
to communicate with the devices. The <code>FuBluezDevice</code> type implements
device enumeration as well as the basic primitives to read and write <span class="caps">BLE</span>
characteristics, and can be used as the base type for a more specific
<span class="caps">BLE</span>&nbsp;device.</p>
<h3 id="battery-checks">Battery checks<a class="md-anchor" href="#battery-checks" title="Permanent link"></a></h3>
<p>If the device can be updated wirelessly or if the update process doesn&#8217;t
rely on an external power supply, the vendor might define a minimum
operative battery level to guarantee a correct update. fwupd provides a
simple <span class="caps">API</span> to define these requirements&nbsp;per-device.</p>
<p><a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-device.c">fu_device_set_battery_threshold()</a>
can be used to define the minimum battery level required to allow a
firmware update on a device (10% by default). If the battery level is
below that threshold, fwupd will inhibit the device to prevent the user
from starting a firmware update. Then, the battery level of a device can
be queried and then set with
<a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-device.c">fu_device_set_battery_level()</a>.</p>
<h2 id="howtos">Howtos<a class="md-anchor" href="#howtos" title="Permanent link"></a></h2>
<h3 id="how-to-create-a-child-device">How to create a child device<a class="md-anchor" href="#how-to-create-a-child-device" title="Permanent link"></a></h3>
<p>fwupd devices can be hierarchically ordered to model dependent and
composite devices such as docking stations composed of multiple
updatable chips. When writing support for a new composite device the
parent device should, at some point, poll the devices that &#8220;hang&#8221; from
it and register them in fwupd. The process of polling and identifying a
child device is totally vendor and device-specific, although the main
requirement for it is that the child device is properly identified
(having physical/logical and instance ids). Then,
<a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-device.c">fu_device_add_child()</a>
can be used to add a new child device to an existing one. See
<code>fu_logitech_hidpp_runtime_bolt_poll_peripherals()</code> in
<a href="https://github.com/fwupd/fwupd/blob/main/plugins/logitech-hidpp/fu-logitech-hidpp-runtime-bolt.c">https://github.com/fwupd/fwupd/blob/main/plugins/logitech-hidpp/fu-logitech-hidpp-runtime-bolt.c</a>
for an&nbsp;example.</p>
<p>Note that when deploying and installing a firmware set for a composite
device, there might be firmware dependencies between parent and child
devices that require a specific update ordering (for instance, child
devices first, then the parent). This can be modeled by setting an
appropriate firmware priority in the firmware metainfo or by setting the
<code>FU_DEVICE_PRIVATE_FLAG_INSTALL_PARENT_FIRST</code> device&nbsp;flag.</p>
<h3 id="how-to-add-a-delay">How to add a delay<a class="md-anchor" href="#how-to-add-a-delay" title="Permanent link"></a></h3>
<p>In certain scenarios you may need to introduce small controlled delays
in the plugin code, for instance, to comply with a communications
protocol or to wait for the device to be ready after a particular
operation. In this case you can insert a delay in microseconds with
<code>g_usleep</code> or a delay in milliseconds that shows a progress bar with
<code>fu_device_sleep</code> or <code>fu_device_sleep_full</code>. Note that, in both cases,
this will stop the application main loop during the wait, so use it only
when&nbsp;necessary.</p>
<h3 id="how-to-define-private-flags">How to define private flags<a class="md-anchor" href="#how-to-define-private-flags" title="Permanent link"></a></h3>
<p>Besides the regular flags and internal flags that any device can have, a
device can define private flags for specific uses. These can be enabled
in the code as well as in quirk files, just as the rest of flags. To
define a private&nbsp;flag:</p>
<ol>
<li>Define the flag value. This is normally defined as a macro that
  expands to a binary flag, for example: <code>#define MY_PRIVATE_FLAG (1 &lt;&lt;
  2)</code>.  Note that this will be part of the <span class="caps">ABI</span>, so it must be&nbsp;versioned</li>
<li>Call <code>fu_device_register_private_flag</code> in the device init function
  and assign a string identifier to the flag:
  <code>fu_device_register_private_flag(FU_DEVICE (self), MY_PRIVATE_FLAG);</code></li>
</ol>
<p>You can then add it to the device programmatically with
<code>fu_device_add_private_flag</code>, remove it with <code>fu_device_remove_private_flag</code>
and query it with <code>fu_device_has_private_flag</code>. In a quirk file, you can
add the flag identifier to the Flags attribute of a device (eg. <code>Flags =
myflag,is-bootloader</code>)</p>
<h3 id="how-to-make-fwupd-wait-for-a-device-replug">How to make fwupd wait for a device replug<a class="md-anchor" href="#how-to-make-fwupd-wait-for-a-device-replug" title="Permanent link"></a></h3>
<p>Certain devices require a disconnection and reconnection to start the
update process. A common example are devices that have two booting
modes: application or runtime mode, and bootloader mode, where the
runtime mode is the normal operation mode and the bootloader mode is
exclusively used to update the device firmware. It&#8217;s common for these
devices to require some operation from fwupd to switch the booting mode
and then to need a reset to enter bootloader mode. Often, the device is
enumerated differently in both modes, so fwupd needs to know that the
same device will be identified differently depending on the boot&nbsp;mode.</p>
<p>The common way to do this is to add the
<code>FWUPD_DEVICE_FLAG_WAIT_FOR_REPLUG</code> flag in the device before its detach
method returns. This will make fwupd wait for a predetermined amount of
time for the device to be detected again. Then, to inform fwupd about
the two identities of the same device, the <code>CounterpartGuid</code> key can be
used in a device entry to match it with another defined device (example:
<a href="https://github.com/fwupd/fwupd/blob/main/plugins/steelseries/steelseries.quirk">https://github.com/fwupd/fwupd/blob/main/plugins/steelseries/steelseries.quirk</a>).</p>
<h3 id="inhibiting-a-device">Inhibiting a device<a class="md-anchor" href="#inhibiting-a-device" title="Permanent link"></a></h3>
<p>If a device becomes unsuitable for an update for whatever reason (see
&#8220;Battery checks&#8221; above for an example), a plugin can temporarily disable
firmware updates on it by calling <a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-device.c">fu_device_inhibit()</a>. The device will
still be listed as present by <code>fwupdmgr get-devices</code>, but fwupd won&#8217;t
allow firmware updates on it.  Device inhibition can be disabled with
<a href="https://github.com/fwupd/fwupd/blob/main/libfwupdplugin/fu-device.c">fu_device_uninhibit()</a>.</p>
<p>Note that there might be multiple inhibits on a specific device, the
device will only be updatable when all of them are&nbsp;removed.</p>
<h2 id="debugging-tips">Debugging tips<a class="md-anchor" href="#debugging-tips" title="Permanent link"></a></h2>
<p>The most important rule when debugging is using the <code>--verbose</code> and
duplicate <code>--verbose</code> flag when running fwupd or&nbsp;fwupdtool.</p>
<h3 id="adding-debug-messages">Adding debug messages<a class="md-anchor" href="#adding-debug-messages" title="Permanent link"></a></h3>
<p>The usual way to print a debug message is using the <code>g_debug</code> macro. Each
relevant module will define its own <code>G_LOG_DOMAIN</code> to tag the debug traces
accordingly. See
<a href="https://docs.gtk.org/glib/logging.html">https://docs.gtk.org/glib/logging.html</a> and
<a href="https://docs.gtk.org/glib/running.html">https://docs.gtk.org/glib/running.html</a> for more&nbsp;information.</p>
<h3 id="inspecting-raw-binary-data">Inspecting raw binary data<a class="md-anchor" href="#inspecting-raw-binary-data" title="Permanent link"></a></h3>
<p>The <code>fu_dump_full</code> and <code>fu_dump_raw</code> functions implement the
printing of a binary buffer to the console as a stream of bytes in
hexadecimal. See <code>libfwupdplugin/fu-common.c</code> for their definitions, you
can find many examples of how to use them in the plugins&nbsp;code.</p>
<h2 id="the-rustgen-helper">The rustgen Helper<a class="md-anchor" href="#the-rustgen-helper" title="Permanent link"></a></h2>
<p>The rustgen script generates C source files that allow parsing, modifying and
querying a packed structure or enumeration.
This functionality is provided as parsing untrusted structured data from devices
or firmware files is something fwupd does <em>a lot</em>, and so it makes sense to
abstract out common code for maintainability reasons.
It also allows us to force best-practices into the plugins without having to
do careful review of buffer reading and&nbsp;writing.</p>
<p>Structures support integers of specific widths, arrays, GUIDs, strings, default
and constant data of variable size.
The generated code is endian safe and if used correctly, is also safe
against malicious&nbsp;data.</p>
<p>In most cases the structure or enumeration will be defined in a <code>.rs</code>
file &#8212; which is the usual file extension of Rust programs.
This was done as the format is heavily inspired by Rust, and it makes editor
highlighting support work correctly.
Although these files <em>look like</em> Rust files they&#8217;re <em>not actually compiled by
rustc</em>, so small differences may be&nbsp;noticeable.</p>
<div class="codehilite"><pre><span></span><code>#[derive(New, Validate, Parse, Default)]
#[repr(C, packed)]
struct FuExampleHdr {
    magic: Guid,
    hdrver: u8,
    hdrsz: u16le = $struct_size,
    payloadsz: u32le,
    flags: u8,
}

#[derive(ToString, FromString)]
#[repr(u8)] // optional, and only required if using the enum as a struct item type
enum FuExampleFamily {
    Unknown,
    Sps,
    Txe = 0x5,
    Me,
    Csme,
}
struct ExamplePacket {
    family: FuExampleFamily = Csme,
    data: [u8; 254],
}
</code></pre></div>

<p>The struct types currently supported&nbsp;are:</p>
<ul>
<li><code>u8</code>: a <code>guint8</code></li>
<li><code>u16le</code>: little endian <code>guint16</code></li>
<li><code>u24</code>: a 24 bit number represented as a <code>guint32</code></li>
<li><code>u32le</code>:  little endian <code>guint32</code></li>
<li><code>u64be</code>:  big endian <code>guint64</code></li>
<li><code>char</code>: a <code>NUL</code>-terminated&nbsp;string</li>
<li><code>Guid</code>: a <span class="caps">GUID</span></li>
<li>Any <code>enum</code> created in the <code>.rs</code> file with <code>#[repr(type)]</code></li>
<li>Any <code>struct</code> previously created in the <code>.rs</code> file</li>
</ul>
<p>Arrays of types are also allowed, with the format <code>[type; multiple]</code>, for&nbsp;example:</p>
<ul>
<li><code>buf: [u8; 3] = 0x123456</code> for a C array of <code>guint8 buf[3] = {0x12, 0x34, 0x56};</code></li>
<li><code>val: [u64be; 7]</code>  for a C array of <code>guint64 val[7] = {0};</code></li>
<li><code>str: [char; 4] = "ABCD"</code> for a C array of <code>gchar buf[4] = {'A','B','C','D'};</code>
  &#8212; <span class="caps">NOTE</span>: <code>fu_struct_example_get_str()</code> would return a <code>NUL</code>-terminated string of <code>ABCD\0</code>.</li>
</ul>
<p>Additionally, default or constant values can be auto-populated with the <code>Default</code> trait:</p>
<ul>
<li><code>$struct_size</code>: the total struct&nbsp;size</li>
<li><code>$struct_offset</code>: the internal offset in the&nbsp;struct</li>
<li>string values, specified <strong>without</strong> double or single&nbsp;quotes</li>
<li>integer values, specified with a <code>0x</code> prefix for base-16 and with no prefix for&nbsp;base-10</li>
<li>previously specified <code>enum</code> values</li>
</ul>
<p>Per-field metadata can also be defined, such&nbsp;as:</p>
<ul>
<li><code>=</code>: set as the default value, or for <code>u8</code> arrays initialize with a padding&nbsp;byte</li>
<li><code>==</code>: set as the default, and is <strong>also</strong> verified during&nbsp;unpacking.</li>
</ul>
<p>Default values and padding will be used when creating a new structure,
for instance using <code>fu_struct_example_new()</code>.</p>
<h3 id="building">Building<a class="md-anchor" href="#building" title="Permanent link"></a></h3>
<p>When building a plugin with meson a generator can be&nbsp;used:</p>
<div class="codehilite"><pre><span></span><code>diff --git a/plugins/example/meson.build b/plugins/example/meson.build
@@ -3,7 +3,6 @@
 plugin_quirks += files(&#39;example.quirk&#39;)
 plugin_builtins += static_library(&#39;fu_plugin_example&#39;,
+  rustgen.process(&#39;fu-example.rs&#39;),
   sources:
</code></pre></div>

<p>&#8230;which creates the files <code>plugins/libfu_plugin_example.a.p/fu-example-struct.c</code>
and <code>plugins/libfu_plugin_example.a.p/fu-example-struct.h</code> in the build&nbsp;tree.</p>
<p>The latter can be included using <code>#include fu-example-struct.h</code> in the
existing plugin&nbsp;code.</p>
<h3 id="structs">Structs<a class="md-anchor" href="#structs" title="Permanent link"></a></h3>
<p>There are traits that control the generation of struct code. These&nbsp;include:</p>
<ul>
<li><code>New</code>: for <code>fu_struct_example_new()</code>, needed to create new&nbsp;instances</li>
<li><code>Validate</code>: for <code>fu_struct_example_validate()</code>, needed to check memory buffers are&nbsp;valid</li>
<li><code>Parse</code>: for <code>fu_struct_example_parse()</code>, to create a struct from a memory&nbsp;buffer</li>
<li><code>Getters</code>: for <code>fu_struct_example_get_XXXX()</code>, to get access to field&nbsp;values</li>
<li><code>Setters</code>: for <code>fu_struct_example_set_XXXX()</code>, to set specific field&nbsp;values</li>
</ul>
<p><code>Getters</code> is implied by <code>Parse</code>, and <code>[Getters,Setters]</code> is implied by <code>New</code>.</p>
<p>Regardless of traits used, the header offset addresses are defined, for&nbsp;instance:</p>
<div class="codehilite"><pre><span></span><code>#define FU_STRUCT_EXAMPLE_OFFSET_MAGIC 0x0
#define FU_STRUCT_EXAMPLE_OFFSET_HDRVER 0x10
#define FU_STRUCT_EXAMPLE_OFFSET_HDRSZ 0x11
#define FU_STRUCT_EXAMPLE_OFFSET_PAYLOADSZ 0x13
#define FU_STRUCT_EXAMPLE_OFFSET_FLAGS 0x17
</code></pre></div>

<p>Any elements defined as a typed array (e.g. <code>[u8; 16]</code>) will also have the element
size defined in&nbsp;bytes:</p>
<div class="codehilite"><pre><span></span><code>#define FU_STRUCT_EXAMPLE_SIZE_MAGIC 0x10
</code></pre></div>

<p>If the default has been set (but not a constant value) the default is also&nbsp;defined:</p>
<div class="codehilite"><pre><span></span><code>#define FU_STRUCT_EXAMPLE_DEFAULT_HDRSZ 24
</code></pre></div>

<p>Finally, the size in bytes of the whole structure is also&nbsp;included:</p>
<div class="codehilite"><pre><span></span><code>#define FU_STRUCT_EXAMPLE_SIZE 0x18
</code></pre></div>

<p><strong><span class="caps">NOTE</span>:</strong> constants never have getters or setters defined &#8212; they&#8217;re constant after all.
They are verified during <code>_validate()</code> and <code>_parse()</code> however.</p>
<h3 id="enums">Enums<a class="md-anchor" href="#enums" title="Permanent link"></a></h3>
<p>There are traits that control the generation of enum code. These&nbsp;include:</p>
<ul>
<li><code>ToString</code>: for <code>fu_example_family_to_string()</code>, needed to create&nbsp;output</li>
<li><code>ToBitString</code>: for <code>fu_example_family_to_string()</code>, needed to create output for&nbsp;bitfields</li>
<li><code>FromString</code>: for <code>fu_example_family_from_string()</code>, needed to parse&nbsp;input</li>
</ul>
<p><strong><span class="caps">NOTE</span>:</strong> Enums are defined as a native unsigned type, and should not be copied by
reference without first casting to an integer of known&nbsp;width.</p>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="#introduction"><span class="link-text">Introduction</span></a></li>
          
        
        <li class="toc-list-item"><a href="#creating-an-abstract-device"><span class="link-text">Creating an abstract device</span></a></li>
          
          <ul class="toc-list">
          
            <li class="toc-list-item"><a href="#setting-the-device-version"><span class="link-text">Setting the device version</span></a></li>
          
          </ul>
          
        
        <li class="toc-list-item"><a href="#mechanism-plugins"><span class="link-text">Mechanism Plugins</span></a></li>
          
        
        <li class="toc-list-item"><a href="#policy-helpers"><span class="link-text">Policy Helpers</span></a></li>
          
        
        <li class="toc-list-item"><a href="#detaching-to-bootloader-mode"><span class="link-text">Detaching to bootloader mode</span></a></li>
          
        
        <li class="toc-list-item"><a href="#the-plugin-object-cache"><span class="link-text">The Plugin Object Cache</span></a></li>
          
        
        <li class="toc-list-item"><a href="#debugging-a-plugin"><span class="link-text">Debugging a Plugin</span></a></li>
          
        
        <li class="toc-list-item"><a href="#using-existing-code-to-develop-a-plugin"><span class="link-text">Using existing code to develop a plugin</span></a></li>
          
        
        <li class="toc-list-item"><a href="#general-guidelines-for-plugin-developers"><span class="link-text">General guidelines for plugin developers</span></a></li>
          
          <ul class="toc-list">
          
            <li class="toc-list-item"><a href="#general-considerations"><span class="link-text">General considerations</span></a></li>
          
            <li class="toc-list-item"><a href="#leveraging-existing-fwupd-code"><span class="link-text">Leveraging existing fwupd code</span></a></li>
          
            <li class="toc-list-item"><a href="#example-extending-a-firmware-type"><span class="link-text">Example: extending a firmware type</span></a></li>
          
            <li class="toc-list-item"><a href="#example-extending-a-device-type"><span class="link-text">Example: extending a device type</span></a></li>
          
            <li class="toc-list-item"><a href="#creating-a-new-plugin"><span class="link-text">Creating a new plugin</span></a></li>
          
            <li class="toc-list-item"><a href="#creating-a-new-device-type"><span class="link-text">Creating a new device type</span></a></li>
          
            <li class="toc-list-item"><a href="#creating-a-new-firmware-type"><span class="link-text">Creating a new firmware type</span></a></li>
          
            <li class="toc-list-item"><a href="#generating-a-skeleton"><span class="link-text">Generating a skeleton</span></a></li>
          
            <li class="toc-list-item"><a href="#device-identification"><span class="link-text">Device identification</span></a></li>
          
            <li class="toc-list-item"><a href="#support-for-ble-devices"><span class="link-text">Support for BLE devices</span></a></li>
          
            <li class="toc-list-item"><a href="#battery-checks"><span class="link-text">Battery checks</span></a></li>
          
          </ul>
          
        
        <li class="toc-list-item"><a href="#howtos"><span class="link-text">Howtos</span></a></li>
          
          <ul class="toc-list">
          
            <li class="toc-list-item"><a href="#how-to-create-a-child-device"><span class="link-text">How to create a child device</span></a></li>
          
            <li class="toc-list-item"><a href="#how-to-add-a-delay"><span class="link-text">How to add a delay</span></a></li>
          
            <li class="toc-list-item"><a href="#how-to-define-private-flags"><span class="link-text">How to define private flags</span></a></li>
          
            <li class="toc-list-item"><a href="#how-to-make-fwupd-wait-for-a-device-replug"><span class="link-text">How to make fwupd wait for a device replug</span></a></li>
          
            <li class="toc-list-item"><a href="#inhibiting-a-device"><span class="link-text">Inhibiting a device</span></a></li>
          
          </ul>
          
        
        <li class="toc-list-item"><a href="#debugging-tips"><span class="link-text">Debugging tips</span></a></li>
          
          <ul class="toc-list">
          
            <li class="toc-list-item"><a href="#adding-debug-messages"><span class="link-text">Adding debug messages</span></a></li>
          
            <li class="toc-list-item"><a href="#inspecting-raw-binary-data"><span class="link-text">Inspecting raw binary data</span></a></li>
          
          </ul>
          
        
        <li class="toc-list-item"><a href="#the-rustgen-helper"><span class="link-text">The rustgen Helper</span></a></li>
          
          <ul class="toc-list">
          
            <li class="toc-list-item"><a href="#building"><span class="link-text">Building</span></a></li>
          
            <li class="toc-list-item"><a href="#structs"><span class="link-text">Structs</span></a></li>
          
            <li class="toc-list-item"><a href="#enums"><span class="link-text">Enums</span></a></li>
          
          </ul>
          
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>